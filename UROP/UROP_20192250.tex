\documentclass[12pt,openany]{book}
\usepackage{amsmath,amsthm,amsfonts,amscd} % Packages for mathematics
\usepackage{commath}
% Colors
\usepackage[dvipsnames, table]{xcolor}
\definecolor{titleblue}{RGB}{0,53,128}
\definecolor{chaptergray}{RGB}{140,140,140}
\definecolor{sectiongray}{RGB}{180,180,180}

\definecolor{thmcolor}{RGB}{231, 76, 60}
\definecolor{defcolor}{RGB}{52, 152, 219}
\definecolor{lemcolor}{RGB}{155, 89, 182}
\definecolor{corcolor}{RGB}{46, 204, 113}
\definecolor{procolor}{RGB}{241, 196, 15}

% Fonts
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{newpxtext,newpxmath}
\usepackage{sectsty}
\allsectionsfont{\sffamily\color{titleblue}\mdseries}

% Page layout
\usepackage{geometry}
\geometry{a4paper,left=1in,right=.7in,top=1in,bottom=1in,heightrounded}
\usepackage{fancyhdr}
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[LO]{\nouppercase{\rightmark}}
\fancyhead[RE]{\nouppercase{\leftmark}}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}

% Chapter formatting
\usepackage{titlesec}
\titleformat{\chapter}[display]
{\normalfont\sffamily\Huge\bfseries\color{titleblue}}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
{\normalfont\sffamily\Large\bfseries\color{titleblue!100!gray}}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\sffamily\large\bfseries\color{titleblue!75!gray}}{\thesubsection}{1em}{}

% Table of contents formatting
\usepackage{tocloft}
\renewcommand{\cftchapfont}{\sffamily\color{titleblue}\bfseries}
\renewcommand{\cftsecfont}{\sffamily\color{chaptergray}}
\renewcommand{\cftsubsecfont}{\sffamily\color{sectiongray}}
\renewcommand{\cftchapleader}{\cftdotfill{\cftdotsep}}

% Hyperlinks
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=titleblue,
	filecolor=black,      
	urlcolor=titleblue,
}

%Listing
\usepackage{listings} %Code
\renewcommand{\lstlistingname}{Code}%

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,1,1}


\lstdefinestyle{sage}{
	language=Python,
	backgroundcolor=\color{white},
	basicstyle=\small\ttfamily\color{black}, 
	basicstyle=\footnotesize\ttfamily\color{black},
	keywordstyle=\color{blue!60!black},
	commentstyle=\color{green!60!black},
	stringstyle=\color{purple!60!black},
	showstringspaces=false,
	breaklines=true,
	tabsize=4,
	morekeywords={True, False, None},
	frame=leftline, % Remove the border
	framesep=3pt,
	frameround=tttt,
	framexleftmargin=3pt,
	numbers=left,
	numberstyle=\small\color{gray},
	xleftmargin=15pt, % Increase the left margin
	xrightmargin=5pt,
	captionpos=b,
	belowskip=0pt,
	aboveskip=4pt
}

%Ceiling and Floor Function
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

%Algorithm
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{setspace}
\usepackage{algpseudocode}
\SetKwComment{Comment}{/* }{ */}
\SetKw{Break}{break}
\SetKw{Downto}{downto}
\SetKwProg{Fn}{Function}{:}{end}
\SetKwFunction{KeyGens}{KeyGens}

\renewcommand{\arraystretch}{1.25}
%---------------------------My Preamble
\usepackage{marvosym} %Lightning
\usepackage{booktabs}
\usepackage{multicol}
\setlength{\columnsep}{2cm}
\setlength{\columnseprule}{1.25pt}
\usepackage{enumerate}
\usepackage{soul}
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$\displaystyle #2$}}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows, arrows.meta, positioning, shapes.multipart}
\usepackage{pgfplots}

%Tcolorbox
\usepackage[most]{tcolorbox}
\tcbset{colback=white, arc=5pt}
%\tcbset{enhanced, colback=white,colframe=black,fonttitle=\bfseries,arc=4mm,boxrule=1pt,shadow={2mm}{-1mm}{0mm}{black!50}}
%White box with black text and shadow
%\begin{tcolorbox}[colback=white,colframe=black,fonttitle=\bfseries,title=Black Shadow Box,arc=4mm,boxrule=1pt,shadow={2mm}{-1mm}{0mm}{black!50}]
%	This is a white box with black text and a subtle shadow. The shadow adds some depth and dimension to the box without overpowering the design.
%\end{tcolorbox}

%Theorem
\newtheorem{axiom}{Axiom}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{construction}{Construction}[chapter]
\newtheorem{remark}{Remark}[chapter]
\newtheorem{exercise}{Exercise}[chapter]
\newtheorem{example}{Example}[chapter]
\newtheorem*{note}{Note}

%New Command
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\G}{\mathbb{G}}

\newcommand{\img}{\operatorname{\textnormal{Img}}}
\newcommand{\id}{\operatorname{\textnormal{Id}}}

\newcommand{\inv}[1]{#1^{-1}}

\newcommand{\ie}{\textnormal{i.e.}}
\newcommand{\eg}{\textnormal{e.g.}}

\newcommand{\of}[1]{\left( #1 \right)} 
\renewcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\renewcommand{\norm}[1]{\left\| #1 \right\|}

\newcommand{\sol}{\textcolor{magenta}{\bf Sol}}

\newcommand{\KeyGen}{\mathsf{KeyGen}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\scheme}{\Sigma}
\newcommand{\keyspace}{\mathcal{K}}
\newcommand{\messagespace}{\mathcal{M}}
\newcommand{\ciphertextspace}{\mathcal{C}}

\newcommand{\library}{\mathcal{L}}
\newcommand{\zero}{\textcolor{red}{\texttt{0}}}
\newcommand{\one}{\textcolor{red}{\texttt{1}}}

\newcommand{\tab}{\hspace{8pt}}
\newcommand{\xor}{\oplus}
\newcommand{\adversary}{\mathcal{A}}
\newcommand{\isequal}{\overset{?}{=}}
\newcommand{\linking}{\diamond}

\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\randomness}{\$}
\newcommand{\uniform}{\xleftarrow{\randomness}}
\newcommand{\binaryfield}{\set{\zero,\one}}

\newcommand{\ctxt}{\texttt{CTXT}}
\newcommand{\eavesdrop}{\texttt{Eavesdrop}}

\newcommand{\ots}{\mathsf{ots}}
\newcommand{\sL}{\mathsf{L}}
\newcommand{\sR}{\mathsf{R}}

\newcommand*{\indist}{%
	\mathrel{\vcenter{\offinterlineskip
			\hbox{$\sim$}\vskip-.35ex\hbox{$\sim$}\vskip-.35ex\hbox{$\sim$}}}}

\newcommand{\outputs}{\Rightarrow}

% Begin document
\begin{document}
	
	% Title page
	\begin{titlepage}
		\begin{center}
			{\Huge\textsf{\textbf{Code-Based Games Philosophy}}\par}
			\vspace{0.5in}
			{\Large Ji Yong-Hyeon, Kim Dong-Hyeon\par}
			\vspace{1in}
			\includegraphics[scale=2.5]{urop.jpg}\par
			\vspace{1in}
			{\bf Department of Information Security, Cryptology, and Mathematics\par}
			{College of Science and Technology\par}
			{Kookmin University\par}
			%\includegraphics[width=1.5in]{school_logo.jpg}\par
			\vspace{.25in}
			{\large \today\par}
		\end{center}
	\end{titlepage}
	
	% Table of contents
	\tableofcontents
	
	% Chapters
	\mainmatter
	
	\chapter*{List of Symbols}
	
	\begin{tabular}{ll}
		\( \zero^\lambda, \one^\lambda\) & \(\underbrace{\zero\zero\cdots\zero}_{\lambda\ \text{times}}, \underbrace{\one\one\cdots\one}_{\lambda\ \text{times}}\) : \(\lambda\)-bit zero/one sequence \\
		\( \adversary\linking\library \) & The result of \textbf{linking} $\adversary$ to  $\library$ \\
		\( \randomness \) & Randomeness \\
		\( \equiv \) & Interchangability; Identical
	\end{tabular}
	
	\chapter{One-Time Pad \& Kerckhoff's Principle}
	
	\begin{tcolorbox}[colback=white,colframe=gray,arc=5pt,title={\color{white}\bf }]
		\textbf{Kerchkhoffs' Principle:}
		\begin{quote}
			Design your system to be secure even if the attacker has complete knowledge of all its algorithms.
		\end{quote}
	\end{tcolorbox}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf One-time Pad (OTP)}]
		\begin{construction}
			The specific \(\KeyGen,\Enc\), and \(\Dec\) algorithms for \textbf{one-time pad} are given below: \begin{center}
				\begin{tabular}{|lll|}
					\hline
					$\underline{\KeyGen:}$ & \(\underline{\Enc(k,m\in\binaryfield^\lambda):}\) & \(\underline{\Dec(k,c\in\binaryfield^\lambda):}\)\\
					\tab$k\uniform\binaryfield^\lambda$ & \tab return \(k\xor m\) & \tab return \(k\xor c\)\\
					\tab return $k$ &&\\
					\hline
				\end{tabular}\\
			\end{center}
		\end{construction}
	\end{tcolorbox}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=procolor,arc=5pt,title={\color{white}\bf Corectness of OTP}]
		\begin{proposition}
			\[
			(\forall k,m\in\binaryfield^\lambda)\quad\Dec(k,\Enc(k,m))=m.
			\]
		\end{proposition}
	\end{tcolorbox}
	\begin{proof}
		Let \(k,m\in\binaryfield^\lambda\) then \begin{align*}
			\Dec(k,\Enc(k,m))=\Dec(k,k\xor m)&=k\xor(k\xor m)\\
			&=(k\xor k)\xor m\\
			&=\zero^\lambda\xor m\\
			&=m.
		\end{align*}
	\end{proof}

	\newpage
	\begin{remark}[\eavesdrop\ Algorithm]
		From Eveâ€™s perspective, seeing a ciphertext corresponds to receiving
		an output from the following algorithm: \\ \begin{center}
		\begin{tabular}{|l|}
			\hline
			\(\underline{\eavesdrop(m\in\binaryfield^\lambda)}\)\\
			\tab\(k\uniform\binaryfield^\lambda\)\\
			\tab\(c:=k\xor m\)\\
			\tab return \(c\)\\
			\hline
		\end{tabular}
		\end{center}
	\end{remark}

	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf }]
		\begin{theorem}
			Let \(m\in\binaryfield^\lambda\). The distribution \(\eavesdrop(m)\) is the \textbf{uniform distribution} on \(\binaryfield^\lambda\). In other words, \[
			m,m'\in\binaryfield^\lambda\implies\textnormal{dist}(\eavesdrop(m))\sim\textnormal{dist}(\eavesdrop(m')).
			\]
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		content...
	\end{proof}
	
	\chapter{The Basics of Provable Security}
	
	\section{How to Write a Security Definition}
	\subsection{Syntax and Correctness}
	
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf Encryption Syntax}]
		\begin{definition}
			A \textbf{symmetric-key encryption (SKE) scheme} consists of the following algorithms: \begin{itemize}
				\item $\KeyGen$ outputs a key $k=\KeyGen(1^\lambda)\in\keyspace$
				\item $\Enc:\keyspace\times\messagespace\to\ciphertextspace$
				\item $\Dec:\keyspace\times\ciphertextspace\to\messagespace$
			\end{itemize} We call $\keyspace$ the \textbf{key space}, $\messagespace$ the \textbf{message space}, and $\ciphertextspace$ the \textbf{ciphertext space} of the scheme.
		\end{definition}
	\end{tcolorbox}
	\begin{remark}
		Note that \begin{itemize}
			\item \(\KeyGen\) is a randomized algorithm\footnote{An algorithm that makes use of random numbers.}.
			\item \(\Enc\) is a (possibly randomized) algorithm\footnote{It could operate deterministically or non-deterministically depending on specific conditions or parameters.}.
			\item \(\Dec\) is a deterministic algorithm\footnote{An algorithm that does produces the same output for the same input, every time it's run.}.
		\end{itemize}
	\end{remark}
	\begin{remark}
		We refer to the entire scheme by a single variable $\scheme$, \ie, $$
		\scheme=(\KeyGen, \Enc, \Dec).
		$$
	\end{remark}
	\begin{remark}
		We write \[
		\begin{array}{ccc}
			\scheme.\KeyGen, & \scheme.\Enc, & \scheme.\Dec,\\
			\scheme.\keyspace, & \scheme.\messagespace, &\scheme.\ciphertextspace
		\end{array}
		\] to refer to its components.
	\end{remark}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf SKE Correctness}]
		\begin{definition}
			An encryption scheme $\scheme$ satisfies \textbf{correctness} if \[
			\left(\forall k\in\scheme.\keyspace\right)\left(\forall m\in\scheme.\messagespace
			\right)\quad\Pr\left[\scheme.\Dec(k, \scheme.\Enc(k,m))=m\right]=1.
			\]
		\end{definition}
	\end{tcolorbox}
	\begin{remark}
		The definition is written in terms of a probability because $\Enc$ is allowed to be a randomized algorithm. In other words, decrypting a ciphertext with the same key that was used for encryption must \textit{always} result in the original plaintext.
	\end{remark}
	\vspace{4pt}
	\begin{example}
		content...
	\end{example}
	
	\subsection{``Real-vs-Random'' Style of Security Definition}
	\begin{quote}
		``an encryption scheme is a good one if its ciphertexts \textit{look like} random junk to an attacker''
	\end{quote}

	Security definitions always consider \textbf{the attacker's view} of the system.
	\begin{quote}
		``an encryption scheme is a good one if its ciphertexts \textit{look like} random junk to an attacker ... when each key is secret and used to encrypt only one plaintext, even when the attacker chooses the plaintexts.''
	\end{quote}

	
	A concise way to express all of these details is to consider \textbf{the attacker as a calling	program} to the following subroutine:
	\begin{center}
		\begin{tabular}{|l|}
			\hline
			$\underline{\texttt{CTXT}(m\in\scheme.\messagespace):}$\\
			\tab$k\gets\scheme.\KeyGen$\\
			\tab$c:=\scheme.\Enc(k,m)$\\
			\tab return $c$\\
			\hline
		\end{tabular}\\
	\end{center}
	
	\begin{example}[One-Time Pad (OTP)]
		a\\ \begin{center}
			\begin{minipage}{.44\textwidth}
				\begin{tabular}{|l|}
					\hline
					$\underline{\texttt{CTXT}(m):}$\\
					\begin{tabular}{ll}
						\tab$k\gets\binaryfield^\lambda$ & \textcolor{gray}{//\(\KeyGen\) of OTP}\\
						\tab$c:=k\xor m$ & \textcolor{gray}{//\(\Enc\) of OTP}\\
						\tab return $c$\\
					\end{tabular}\\
					\hline
				\end{tabular}\\
			\end{minipage} vs.
		\begin{minipage}{.3\textwidth}
			\begin{tabular}{|l|}
				\hline
				$\underline{\texttt{CTXT}(m):}$\\
				\begin{tabular}{ll}
					\tab$c:=\binaryfield^\lambda$ & \textcolor{gray}{//\(\ciphertextspace\) of OTP}\\
					\tab return $c$\\
				\end{tabular}\\
				\hline
			\end{tabular}\\
		\end{minipage}
		\end{center}
	\end{example}

	\begin{quote}
		``an encryption scheme is a good one if, when you plug its \(\KeyGen\) and \(\Enc\) algorithms into the template of the \texttt{CTXT} subroutine above, the two implementations of \texttt{CTXT} induce identical behavior in every calling program.''
	\end{quote}

	\subsection{``Left-vs-Right'' Style of Security Definition}
	
	\section{Formalisms for Security Definition}
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf Library}]
		\begin{definition}
			A \textbf{library} $\library$ is a collection of subroutines and private/static variables.
		\end{definition}
	\end{tcolorbox}
	\begin{example}
		Here is a familiar library and one possible calling program:
		\begin{center}
			\begin{minipage}{.25\textwidth}
				\begin{tabular}{|c|}
					\hline
					\cellcolor{blue!25}$\library$\\
					\hline
					\begin{tabular}{l}
						\underline{\texttt{CTXT}($m$):}\\
						\tab $k\uniform\set{\zero, \one}^\lambda$\\
						\tab $c:=k\xor m$\\
						\tab return $c$
					\end{tabular}\\
					\hline
				\end{tabular}\quad,\quad
			\end{minipage}
			\begin{minipage}{.25\textwidth}
				\begin{tabular}{|c|}
					\hline
					\cellcolor{blue!25}$\adversary$\\
					\hline
					\begin{tabular}{l}
						$m\gets\set{\zero,\one}^\lambda$\\
						$c:=\texttt{CTXT}(m)$\\
						return $m\isequal c$
					\end{tabular}\\
					\hline
				\end{tabular}
			\end{minipage}.
		\end{center} Then \[
		\Pr\left[\adversary\linking\library\Rightarrow\true\right]=\frac{1}{2^\lambda}.
		\]
	\end{example}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf Interchangeability}]
		\begin{definition}
			Let $\library_1$ and $\library_2$ be two libraries that have the same interface. We say that $\library_1$ and $\library_2$ are \textbf{interchangeable}, and write $\library_1\equiv\library_2$, if $\forall\adversary:$\[
			\Pr\left[\adversary\linking\library_1\Rightarrow\true\right]=
			\Pr\left[\adversary\linking\library_2\Rightarrow\true\right].
			\]
		\end{definition}
	\end{tcolorbox}
	\vspace{8pt}

	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf One-Time Uniform Ctxts}]
		\begin{definition}
			An encryption scheme $\scheme$ has \textbf{one-time uniform cipher-texts} if 
			\begin{center}
				\begin{minipage}{.3\textwidth}
					\begin{tabular}{|c|}
						\hline
						\cellcolor{blue!25}$\library_{\text{ots\$-real}}^\scheme$\\
						\hline
						\begin{tabular}{l}
							\underline{\texttt{CTXT}($m\in\scheme.\messagespace$):}\\
							\tab $k\gets\scheme.\KeyGen$\\
							\tab $c\gets\scheme.\Enc(k,m)$\\
							\tab return $c$
						\end{tabular}\\
						\hline
					\end{tabular}
				\end{minipage}
				$\equiv$\quad
				\begin{minipage}{.3\textwidth}
					\begin{tabular}{|c|}
						\hline
						\cellcolor{blue!25}$\library_{\text{ots\$-rand}}^\scheme$\\
						\hline
						\begin{tabular}{l}
							\underline{\texttt{CTXT}($m\in\scheme.\messagespace$)}:\\
							\tab $c\gets\scheme.\ciphertextspace$\\
							\tab return $c$
						\end{tabular}\\
						\hline
					\end{tabular}
				\end{minipage}
			\end{center}
		\end{definition}
	\end{tcolorbox}

	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf One-Time Secrecy (\(\mathsf{OTS})\)}]
		\begin{definition}\textbf{
			One-time secrecy} is a property of an encryption scheme where an adversary cannot gain any information about the plaintext message from the ciphertext, even if they know the encryption key was used only once.
			\begin{center}
				\begin{minipage}{.3\textwidth}
					\begin{tabular}{|c|}
						\hline
						\cellcolor{blue!25}$\library_{\ots-\sL}^\scheme$\\
						\hline
						\begin{tabular}{l}
							\underline{\texttt{Eve}($m_L,m_R\in\scheme.\messagespace$):}\\
							\tab $k\gets\scheme.\KeyGen$\\
							\tab $c\gets\scheme.\Enc(k,m_L)$\\
							\tab return $c$
						\end{tabular}\\
						\hline
					\end{tabular}
				\end{minipage}
				$\equiv$
				\begin{minipage}{.3\textwidth}
					\begin{tabular}{|c|}
						\hline
						\cellcolor{blue!25}$\library_{\ots-\sR}^\scheme$\\
						\hline
						\begin{tabular}{l}
							\underline{\texttt{Eve}($m_L,m_R\in\scheme.\messagespace$):}\\
							\tab $k\gets\scheme.\KeyGen$\\
							\tab $c\gets\scheme.\Enc(k,m_R)$\\
							\tab return $c$
						\end{tabular}\\
						\hline
					\end{tabular}
				\end{minipage}
			\end{center}
		\end{definition}
	\end{tcolorbox}
	
	\section{How to Demonstrate Insecurity with Attacks}
	\section{How to Prove Security with The Hybrid Technique}
	\section{How to Compare/Contract Security Definitions}
	
	\newpage
	\section*{Exercises}
	
	\begin{itemize}
		\item[\bf 2.5.] In abstract algebra, a (finite) group is a finite set $\mathbb{G}$ of items together with an operator $\otimes$ satisfying the following axioms:
		\begin{itemize}
			\item \textbf{Closure:} for all \(a,b\in\mathbb{G}\), we have $a\otimes b\in \mathbb{G}$
			\item \textbf{Identity:} there is a special \textit{identity element} $e\in\G$ that satisfies \(e\otimes a = a\otimes e = a\) for
			all \(a\in\G\). We typically write ``1'' rather than $e$ for the identity element.
			\item \textbf{Associativity:} for all \(a, b, c\in\G\), we have \((a\otimes b)\otimes c = a\otimes (b\otimes c)\).
			\item \textbf{Inverses:} for all \(a\in\G\), there exists an inverse element \(b\in\G\) such that \(a\otimes b = b\otimes a\)
			is the identity element of $\G$. We typically write ``$a^{-1}$'' for the inverse of $a$.
		\end{itemize}
	
		Define the following encryption scheme in terms of an arbitrary group \((\G, \otimes)\):
		\begin{center}
			\begin{tabular}{|clll|}
				\hline
				\(\keyspace=\G\) & \(\underline{\KeyGen:}\) & \(\underline{\Enc(k,m):}\) &\(\underline{\Dec(k,c):}\) \\
				\(\messagespace=\G\) & \tab\(k\gets\G\) & \tab return \(k\otimes m\) & \tab ??\\
				\(\ciphertextspace=\G\) & \tab return \(k\) &&\\
				\hline
			\end{tabular}
		\end{center}
		\begin{enumerate}[(a)]
			\item Prove that \(\binaryfield^\lambda\) is a group with respect to the xor operator. What is the identity
			element, and what is the inverse of a value $x\in\binaryfield^\lambda$?
			\item Fill in the details of the $\Dec$ algorithm and prove (using the group axioms) that the scheme satisfies correctness.
			\item Prove that the scheme satisfies one-time secrecy.
		\end{enumerate}
		\begin{tcolorbox}[colframe=magenta, breakable, enhanced]
			\begin{proof}[\sol]
				\begin{enumerate}[(a)]
					\item We show that \((\binaryfield^\lambda,\xor)\) satisfies the group axioms:
					\begin{itemize}
						\item[] \textbf{Closure:} \(x,y\in\binaryfield^\lambda\implies x\xor y\in\binaryfield^\lambda\)
						\item[] \textbf{Associativity:} The XOR operation is associative, so this property holds.
						\item[] \textbf{Identity:} The identity for XOR is the all-zero \(\lambda\)-bit string \(\zero^\lambda\) because \[
						(\forall x\in\binaryfield^\lambda)\quad x\xor\zero^\lambda=\zero^\lambda\xor x= x.
						\]
						\item[] \textbf{Inverse:} The inverse of $x$ under XOR is $x$ itself because \[
						x\xor x=\zero^\lambda.
						\]
					\end{itemize}
					\vspace{4pt}
					\item Decryption Algorithm: \begin{center}
						\begin{tabular}{l}
							\(\underline{\Dec(k,c):}\) \\ \tab return \(\inv{k}\otimes c\)
						\end{tabular}
					\end{center}
					Proof of Correctness: \begin{align*}
						\Dec(k,\Enc(k,m))&=\inv{k}\otimes\Enc(k,m)\\
						&=\inv{k}\otimes(k\otimes m)\\
						&=(\inv{k}\otimes k)\otimes m\\
						&=1\otimes m\\
						&=m.
					\end{align*}
					\item Let $m_L,m_R\in\G$ with $m_L\neq m_R$, and let $k\in\G$. The ciphertexts for theses message are \begin{align*}
						&c_L:=m_L\otimes k,\\
						&c_R:=m_R\otimes k.
					\end{align*} Let $\G:=\binaryfield^\lambda$ and $\otimes:=\xor$. Then \begin{align*}
						c_L\otimes c_R&=(m_L\otimes k)\otimes(m_R\otimes k)\\
						&=m_L\otimes m_R\otimes(k\otimes k)\\
						&=m_L\otimes m_R.
					\end{align*} This result does not reveal any information about $k$, and it would be the same if the attacker knew $m_L$ and $m_R$ but did not know $k$. Therefore, the scheme satisfies one-time secrecy.
					
					Note that if $\G=\binaryfield^\lambda$ and $\otimes=\xor$ then
					\begin{center}
						\begin{minipage}{.46\textwidth}
							\begin{tabular}{|c|}
								\hline
								\cellcolor{blue!25}$\library_{\ots-\sL}^\scheme$ \\
								\hline
								\begin{tabular}{l}
									\underline{\texttt{Eve}($m_L,m_R\in\G$):}\\
									\tab $k\gets\G$\quad\textcolor{gray}{//\(\scheme.\KeyGen\)}\\
									\tab $c\gets k\otimes m_L$\quad\textcolor{gray}{//\(\scheme.\Enc(k,m_L)\)}\\
									\tab return $c$
								\end{tabular}\\
								\hline
							\end{tabular}
						\end{minipage}$\equiv$
					\begin{minipage}{.46\textwidth}
					\begin{tabular}{|c|}
						\hline
						\cellcolor{blue!25}$\library_{\ots-\sR}^\scheme$ \\
						\hline
						\begin{tabular}{l}
							\underline{\texttt{Eve}($m_L,m_R\in\G$):}\\
							\tab $k\gets\G$\quad\textcolor{gray}{//\(\scheme.\KeyGen\)}\\
							\tab $c\gets k\otimes m_R$\quad\textcolor{gray}{//\(\scheme.\Enc(k,m_R)\)}\\
							\tab return $c$
						\end{tabular}\\
						\hline
					\end{tabular}
				\end{minipage}
					\end{center}
				\end{enumerate}
			\end{proof}
		\end{tcolorbox}
		\vspace{8pt}
		\item[\bf 2.11] \(\mathcolorbox{yellow}{\text{Prove that if an encryption scheme}\ \scheme\ \text{has}\ \abs{\scheme.\keyspace}<\abs{\scheme.\messagespace}}\) \hl{then it cannot satisfy one-time secrecy}. Try to structure your proof as an explicit attack on such a scheme (\ie, a distinguisher against the appropriate libraries).
		
		The $\Enc$ algorithm of one-time pad is deterministic, but our definitions of encryption allow $\Enc$ to be randomized (\ie, it may give different outputs when called twice with the same $k$ and $m$).
		\textbf{For full credit}, you should prove the statement even for the case of $\Enc$ is randomized. However, you may assume that $\Dec$ is deterministic.
		
		\textcolor{gray}{[Hint: The definition of interchangeability does not place any restriction on the running time of the distinguisher/calling program. Even an exhaustive brute-force attack would be valid]}
		\begin{tcolorbox}[colframe=magenta]
			\begin{proof}[\sol]
				There must exists at least one message that cannot be encrypted by and key in the key space.
				
				Let's consider two distinct messages
				
				The adversary's goal is to distinguish between these two libraries. If the adversary can do this with a probability significantly better than random guessing, then the encryption scheme does not satisfy one-time secrecy.
				
				Let \(\abs{\scheme.\keyspace}<\abs{\scheme.\messagespace}\) then \[
				\exists m^*\in\scheme.\messagespace:m^*\notin\img(\Enc_{k\in\scheme.\keyspace}).
				\]
			\end{proof}
		\end{tcolorbox}
		
	\end{itemize}
	
	\newpage
	\chapter{Cryptography on Intractable Computations}
	
	
	\section{What Qualifies as a ``Computationally Infeasible'' Attack?}
	\begin{tcolorbox}[colframe=defcolor,title={\color{white}\bf Polynomial Time}]
		\begin{definition}
			A program runs in \textbf{polynomial time} if \[
			\exists c>0:\forall n\geq n_0:\mathsf{Time}(n)\leq n^c,
			\] where \(\mathsf{Time}\) is the time taken by the algorithm on inputs of size \(n\). \(n_0\) is constant size of  the input. That is, there exists a constant $c > 0$ such that for all sufficiently long input strings $x$ with $\abs{x}=n$, the program stops after no more than $O(n^c)$ steps.
		\end{definition}
	\end{tcolorbox}
	\begin{remark}
		We see ``\textcolor{blue}{polynomial-time}'' as a synonym for ``\textcolor{blue}{efficient}.''
	\end{remark}

	\begin{example}
		\(\gcd(a,b)\) can be computed using \(O((\log_2a)^3)\) bit operation if \(a>b\).
	\end{example}
	\begin{example}
		\ \begin{table}[h!]\centering
			\begin{tabular}{l|l}
				\textbf{Efficient algorithm known:} & \textbf{No known efficient algorithm:}\\
				Computing GCDs & Factoring integers\\
				Arithmetic \(\bmod N\) & Computing \(\phi(N)\) given \(N\) \\
				Inverses \(\bmod N\) & Discrete logarithm \\
				Exponentiation \(\bmod N\) & Square roots \(\bmod\) composite \(N\) \\
			\end{tabular}
		\end{table}
	
		Again, ``efficient'' means polynomial-time. Furthermore, we only consider polynomial-time algorithms that run on standard, \textit{classical} computers. In fact, all of the problems in the right-hand column \textit{do} have known polynomial-time algorithms on \textit{quantum} computers.
	\end{example}

	\newpage
	\section{What Qualifies as a ``Negligible'' Success Probability?}
	For a cryptographic system to be considered secure, we often want the success probability of any polynomial-time adversary to be negligible in the security parameter \(\lambda\).  
	\begin{quote}
		\(\frac{1}{2^\lambda}\) \textbf{approaches zero so fast that no polynomial can ``rescue''}.
	\end{quote} 
	\begin{proof}
		Assume that \(f(\lambda)=\frac{1}{2^\lambda}\). \begin{center}
			\begin{tikzpicture}[scale=.9]
				\begin{axis}[
					axis lines = left,
					xlabel = \(\lambda\),
					ylabel = \(f\),
					ymin = 0, ymax = 1.5,
					xmin = 0, xmax = 5,
					]
					\addplot [
					domain=0:5, 
					samples=100, 
					color=red,
					]
					{1/2^x};
					\addlegendentry{\(\frac{1}{2^\lambda}\)}
				\end{axis}
			\end{tikzpicture}
		\end{center} Consider any polynomial \(p(\lambda)\) of degree \(n\), written as: \[
		p(\lambda)=a_0+a_1\lambda+a_2\lambda^2+\cdots+a_n\lambda^n=\sum_{i=0}^{n}a_i\lambda^i.
		\] The product \(p(\lambda)\) and \(f(\lambda)\) is \[
		p(\lambda)f(\lambda)=a_0\frac{1}{2^\lambda}+a_1\frac{\lambda}{2^\lambda}+\cdots+a_n\frac{\lambda^n}{2^\lambda}.
		\] We claim that $\displaystyle
		\lim\limits_{\lambda\to\infty}a_k\frac{\lambda^k}{2^\lambda}=0,
		$ where \(k\in\Z_{\geq 0}\). Let \(g(\lambda)=\lambda^k\) and \(h(\lambda)=2^\lambda\). Note that 
		\begin{align*}
			h'(\lambda)=2^\lambda(\ln 2),\quad &g'(\lambda)=k\lambda^{k-1}\\
			h''(\lambda)=2^\lambda(\ln 2)^2,\quad &g''(\lambda)=k(k-1)\lambda^{k-2}\\
			&\vdots\\
			h^{(k)}(\lambda)=2^\lambda(\ln 2)^k,\quad&g^{(k)}(\lambda)=k!.
		\end{align*} By applying L'H\^{o}pital's Rule \(k\) times, we have \[
		\lim\limits_{\lambda\to\infty}=\frac{\lambda^k}{2^\lambda}=\lim\limits_{\lambda\to\infty}\frac{k!}{2^\lambda(\ln 2)^k}=0.
		\] Thus, \(\lim\limits_{\lambda\to\infty}p(\lambda)f(\lambda)=0\).
	\end{proof}
	\begin{tcolorbox}[colframe=defcolor,title={\color{white}\bf Negligible}]
		\begin{definition}
			A function \(f\) is \textbf{negligible} if, \[
			\forall\text{polynomial}\ p:\lim\limits_{\lambda\to\infty}p(\lambda)f(\lambda)=0.
			\] In other words, a negligible function approaches zero so fast that you can never catch up when mutiplying by a polynomial.
		\end{definition}
	\end{tcolorbox}
	\begin{remark}
		As $\textcolor{blue}{\lambda}$ (\textcolor{blue}{security parameter}) gets larger and larger, the product of \(\textcolor{blue}{p(\lambda)}\) (\textcolor{blue}{resources or capabilities for an adversary}) and \(\textcolor{blue}{f(\lambda)}\) (\textcolor{blue}{success probability}) approaches \(0\).
	\end{remark}
	\vspace{8pt}
	\begin{tcolorbox}[colframe=procolor,title={\color{white}\bf }]
		\begin{proposition}
			Let \(c\in\Z\). \[
			\lim\limits_{\lambda\to\infty}\lambda^cf(\lambda)=0\implies\text{$f$ is negligible}.
			\]
		\end{proposition}
	\end{tcolorbox}
	\begin{proof}
		Suppose that \(f\) satisfies \(\lim\limits_{\lambda\to\infty}\lambda^c f(\lambda)=0\) for any \(c\in\Z\), and take an arbitrary polynomial \(p\) of degree \(n\). Since \(\lim\limits_{\lambda\to\infty}\frac{p(\lambda)}{\lambda^{n+1}}=0\), we have \[
		\lim\limits_{\lambda\to\infty}p(\lambda)f(\lambda)=\lim\limits_{\lambda\to\infty}\left[\frac{p(\lambda)}{\lambda^{n+1}}\left(\lambda^{n+1}\cdot f(\lambda)\right)\right]=\left(\lim\limits_{\lambda\to\infty}\frac{p(\lambda)}{\lambda^{n+1}}\right)\left(\lim\limits_{\lambda\to\infty}\lambda^{n+1} f(\lambda)\right) = 0\cdot 0=0.
		\]
	\end{proof}
	\vspace{8pt}
	\begin{example}
		Let \(c\in\Z\). Then \[
		\lim\limits_{\lambda\to\infty}\lambda^c\frac{1}{2^\lambda}=
		\lim\limits_{\lambda\to\infty}\frac{(\lambda^c)^{\log_2 2}}{2^\lambda}=
		\lim\limits_{\lambda\to\infty}\frac{2^{c\log_2\lambda}}{2^\lambda}=
		\lim\limits_{\lambda\to\infty}2^{c\log_2(\lambda)-\lambda}=0
		\] since \(c\log_2(\lambda)-\lambda\to-\infty\) as \(\lambda\to\infty\).
		 Thus, \(1/2^\lambda\) is negligible.
	\end{example}

	\begin{tcolorbox}[colframe=defcolor,title={\color{white}\bf \(f\approx g\)}]
		\begin{definition}
			Let \(f,g:\N\to\R\) are real-valued functions. We write \(f\approx g\) to mean that \(\abs{f(\lambda)-g(\lambda)}\) is a negligible function.
		\end{definition}
	\end{tcolorbox}

	\begin{remark}
		We use the terminology of negligible functions exclusively when discussing probabilities, so the following are common: \begin{align*}
			\Pr[X]\approx 0 &\Leftrightarrow \text{``event $X$ almost never happens''}\\
			\Pr[Y]\approx 1 &\Leftrightarrow \text{``event $Y$ almost always happens''}\\
			\Pr[A]\approx \Pr[B] &\Leftrightarrow \text{``event $A$ and $B$ happen with essentially the same probability''}
		\end{align*}
		Additionally, the \(\approx\) symbol is \textit{transitive}: \[
		\Pr[X]\approx\Pr[Y]\land\Pr[Y]\approx\Pr[Z]\implies\Pr[X]\approx\Pr[Z].
		\]
	\end{remark}

	\newpage
	\section{Indistinguishability}
	\begin{tcolorbox}[colframe=defcolor,title={\color{white}\bf Indistinguishable ($\indist$)}]
		\begin{definition}
			Let \(\library_{1}\) and \(\library_{2}\) be two libraries with a common interface, and let \(\adversary\) is a polynomial-time program that output a single bit. We say that \(\library_1\) and \(\library_2\) are \textbf{indistinguishable}, and write \(\library_{1}\indist\library_{2}\), if \[
			\Pr\sbr{\adversary\linking\library_{1}\outputs 1}\approx
			\Pr\sbr{\adversary\linking\library_{2}\outputs 1}.
			\]
		\end{definition}
	\end{tcolorbox}
	\begin{remark}
		\ \begin{enumerate}[(1)]
			\item We call the quantity \[
			\abs{\Pr\sbr{\adversary\linking\library_{1}\outputs 1}-
			\Pr\sbr{\adversary\linking\library_{2}\outputs 1}}
			\] the \textbf{advantage} (or \textbf{bias}) of \(\adversary\) in distinguishing \(\library_{1}\) and \(\library_{2}\).
			\item Two libraries are indistinguishable if all polynomial-time calling programs have negligible advantage in distinguishing them.
		\end{enumerate}
	\end{remark}
	
	\section{Birthday Probabilities \& Sampling With/out Replacement}
	
	
	\newpage
	\newpage
	\section*{Exercises}
	
	\begin{itemize}
		\item[\bf 4.4.] Show that when $f$ is negligible, then for every polynomial $p$, the function $p(\lambda)f(\lambda)$ not only approaches $0$, but it is also negligible itself.
		\begin{tcolorbox}[colframe=magenta, breakable, enhanced]
			\begin{proof}[\sol]
				We want to show that \[
				p(\lambda)f(\lambda)\ \text{is non-negligible}\implies\text{$f$ is non-negligible}.
				\] Suppose that \[
				\exists\text{polynomial}\ q(\lambda):\lim\limits_{\lambda\to\infty}q(\lambda)p(\lambda)f(\lambda)=c\neq0.
				\] Then \(p\) is non-zero polynomial and $f$ is non-zero function, and so \[
				\lim\limits_{\lambda\to\infty} q(\lambda)=\frac{c}{\lim\limits_{\lambda\to\infty}p(\lambda)f(\lambda)}=\frac{c}{\text{constant}}.
				\] Thus \(\lim\limits_{\lambda\to\infty}p(\lambda)f(\lambda)\) cannot be a zero.
			\end{proof}
		\end{tcolorbox}
		\vspace{8pt}
		\item[\bf 4.8.] A deterministic program is one that uses no random choices. Suppose $\library_{1}$ and $\library_{2}$ are two deterministic libraries with a common interface. Show that either $\library_{1}\equiv\library_{2}$, or else $\library_{1}\&\library_{2}$ can be distinguished with advantage 1.
		\begin{tcolorbox}[colframe=magenta, breakable, enhanced]
			\begin{proof}[\sol]
				Since both \(\library_{1}\) and \(\library_{2}\) are deterministic libraries, either \[
				\library_{1}(x)=\library_{2}(x)\quad\text{or}\quad \library_{1}(x)\neq\library_{2}(x)
				\] for any input \(x\).
				\begin{enumerate}[(i)]
					\item ($\library_{1}(x)=\library_{2}(x)$) Clearly, \[
					(\forall\text{input}\ x:\library_{1}(x)=\library_{2}(x)) \implies(\library_{1}\equiv\library_{2}).
					\]
					\item ($\library_{1}(x)\neq\library_{2}(x)$) Suppose that \[
					\exists\text{input}\ x:\library_{1}(x)\neq\library_{2}(x).
					\] 
				\end{enumerate}
			\end{proof}
		\end{tcolorbox}
		\vspace{8pt}
		\item[\bf 4.12.] Suppose you want to enforce password rules so that at least \(2^{128}\) passwords satisfy the
		rules. How many characters long must the passwords be, in each of these cases?
		\begin{enumerate}[(a)]
			\item Passwords consist of lowercase \textcolor{red!70!black}{\texttt{a}} through \textcolor{red!70!black}{\texttt{z}} only.
			\item Passwords consist of lowercase and uppercase letters \textcolor{red!70!black}{\texttt{a}}-\textcolor{red!70!black}{\texttt{z}} and \textcolor{red!70!black}{\texttt{A}}-\textcolor{red!70!black}{\texttt{Z}}.
			\item Passwords consist of lower/uppercase letters and digits \textcolor{red!70!black}{\texttt{0}}-\textcolor{red!70!black}{\texttt{9}}.
			\item Passwords consist of lower/uppercase letters, digits, and any symbol characters that appear on a standard US keyboard (including the space character).\begin{figure}[h!]
				\centering
				\includegraphics[scale=.8]{us_std_keyboard.png}
				\caption{Standard US Keyboard ( \url{https://kbd-intl.narod.ru/english/layouts})}
			\end{figure}
		\end{enumerate}
		\begin{tcolorbox}[colframe=magenta, breakable, enhanced]
			\begin{proof}[\sol]
				We want to create a password system that allows for at least \(2^{128}\) (16 bytes) different passwords.
				\begin{enumerate}[(a)]
					\item We are only using lowercase letters \textcolor{red!70!black}{\texttt{a}}-\textcolor{red!70!black}{\texttt{z}}, which gives us \textbf{26} different possibilities for each character in the password. We need to solve the following equation for 
					\(n\) (the length of the password): \[
					26^n\geq 2^{128}.
					\] Then \[
					n\log(26)\geq 128\log(2)\implies n\geq\frac{128\cdot\log(2)}{\log(26)}\approx 27.2.
					\]
					\item \[
					52^n\geq 2^{128}\implies
					n\geq\frac{128\cdot\log(2)}{\log(52)}\approx 22.4.
					\]
					\item \[
					62^n\geq 2^{128}\implies n\geq\frac{128\cdot\log(2)}{\log(62)}\approx 21.5
					\]
					\item \[
					95^n\geq 2^{128}\implies n\geq\frac{128\cdot\log(2)}{\log(95)}\approx 19.5
					\]
				\end{enumerate}
			\end{proof}
		\end{tcolorbox}
		\begin{figure}[h!]
			\centering
			\includegraphics[scale=.75]{4_12.png}
		\end{figure}
		\begin{lstlisting}[style=sage]
import matplotlib.pyplot as plt

# Given values of X and Y
X_values = [8, 16, 32, 64, 128, 256]
Y_values = [26, 52, 62, 95]

# Initialize a plot
plt.figure(figsize=(10,6))

# Loop through each Y value
	for Y in Y_values:
	# Calculate the expression for each X value
	Z = [x * log(2) / log(Y) for x in X_values]
	
	# Plot the result
	plt.plot(X_values, Z, label='Y=' + str(Y), marker='o')

# Labeling the plot
plt.title(r'Graph of $\frac{X \log(2)}{\log(Y)}$')
plt.xlabel('X')
plt.ylabel(r'$\frac{X \log(2)}{\log(Y)}$')
plt.xscale("log", base=2) # for logarithmic scale on x-axis
plt.legend()
plt.grid(True)
plt.show()
\end{lstlisting}
	\end{itemize}
	% End document
\end{document}
